package es.eriktorr.katas.orders.infrastructure.database;

import es.eriktorr.katas.orders.domain.common.Clock;
import es.eriktorr.katas.orders.domain.exceptions.OrderCreatedEventConflictException;
import es.eriktorr.katas.orders.domain.model.Order;
import es.eriktorr.katas.orders.domain.model.OrderCreatedEvent;
import lombok.val;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.sql.Timestamp;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;

import static es.eriktorr.katas.orders.domain.model.OrderCreatedEvent.ORDER_CREATED_EVENT_HANDLE;

public class EventStoreRepository {

    private static final int ORDER_CREATED_EVENT_DISCRIMINATOR = 1;

    private final JdbcTemplate jdbcTemplate;
    private final EventStorePreparedStatementCreator eventStorePreparedStatementCreator;
    private final Clock clock;

    public EventStoreRepository(JdbcTemplate jdbcTemplate, EventStorePreparedStatementCreator eventStorePreparedStatementCreator, Clock clock) {
        this.jdbcTemplate = jdbcTemplate;
        this.eventStorePreparedStatementCreator = eventStorePreparedStatementCreator;
        this.clock = clock;
    }

    public Mono<OrderCreatedEvent> save(Mono<Order> order) {
        return Mono.defer(() -> order.map(this::orderCreatedEventFrom))
                .subscribeOn(Schedulers.elastic());
    }

    private OrderCreatedEvent orderCreatedEventFrom(Order order) {
        val keyHolder = new GeneratedKeyHolder();
        val timestamp = clock.currentTimestamp();
        val rowsCount = new JdbcTemplateAdvisoryLock(jdbcTemplate, ORDER_CREATED_EVENT_DISCRIMINATOR).execute(() -> {
            try {
                jdbcTemplate.queryForObject("SELECT aggregate_id FROM event_store WHERE payload->>'store' = ? AND payload->>'reference' = ?",
                        new Object[]{ order.getStoreId().getValue(), order.getOrderReference().getValue() }, String.class);
                return 0;
            } catch (EmptyResultDataAccessException exception) {
                return jdbcTemplate.update(preparedStatementCreatorFor(order, timestamp), keyHolder);
            }
        });
        failWhenNoRowIsCreated(rowsCount);
        val eventId = eventIdOrError(generatedKeys(keyHolder));
        return OrderCreatedEvent.build(eventId, timestamp.toLocalDateTime(), order);
    }

    private void failWhenNoRowIsCreated(int rowsCount) {
        if (rowsCount < 1) {
            throw new OrderCreatedEventConflictException("cannot create an order created event in the database");
        }
    }

    private PreparedStatementCreator preparedStatementCreatorFor(Order order, Timestamp timestamp) {
        return connection -> eventStorePreparedStatementCreator.preparedStatementFor(timestamp, ORDER_CREATED_EVENT_HANDLE, order, connection);
    }

    private Map<String, Object> generatedKeys(KeyHolder keyHolder) {
        return Optional.ofNullable(keyHolder.getKeys())
                .orElse(Collections.emptyMap());
    }

    private long eventIdOrError(Map<String, Object> keys) {
        return (long) Optional.ofNullable(keys.get("event_id"))
                .orElseThrow(() -> new IllegalStateException("cannot get autogenerated event Id from database"));
    }

}