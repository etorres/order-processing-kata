package es.eriktorr.katas.orders.infrastructure.database;

import es.eriktorr.katas.orders.domain.common.Clock;
import es.eriktorr.katas.orders.domain.exceptions.OrderCreatedEventConflictException;
import es.eriktorr.katas.orders.domain.model.Order;
import es.eriktorr.katas.orders.domain.model.OrderCreatedEvent;
import es.eriktorr.katas.orders.infrastructure.json.OrderJsonMapper;
import lombok.val;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.sql.Timestamp;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;

import static es.eriktorr.katas.orders.domain.model.OrderCreatedEvent.ORDER_CREATED_EVENT_HANDLE;
import static es.eriktorr.katas.orders.infrastructure.common.EventStorePreparedStatementCreator.preparedStatementFor;

public class EventStoreRepository {

    private final JdbcTemplate jdbcTemplate;
    private final OrderJsonMapper orderJsonMapper;
    private final Clock clock;

    public EventStoreRepository(JdbcTemplate jdbcTemplate, OrderJsonMapper orderJsonMapper, Clock clock) {
        this.jdbcTemplate = jdbcTemplate;
        this.orderJsonMapper = orderJsonMapper;
        this.clock = clock;
    }

    public Mono<OrderCreatedEvent> save(Mono<Order> order) {
        return Mono.defer(() -> order.map(this::orderCreatedEventFrom))
                .subscribeOn(Schedulers.elastic());
    }

    private OrderCreatedEvent orderCreatedEventFrom(Order order) {
        val keyHolder = new GeneratedKeyHolder();
        val timestamp = clock.currentTimestamp();
        val rowsCount = jdbcTemplate.update(preparedStatementCreatorFor(order, timestamp), keyHolder);
        failWhenNoRowIsCreated(rowsCount);
        val eventId = eventIdOrError(generatedKeys(keyHolder));
        return OrderCreatedEvent.build(eventId, timestamp.toLocalDateTime(), order);
    }

    private void failWhenNoRowIsCreated(int rowsCount) {
        if (rowsCount < 1) {
            throw new OrderCreatedEventConflictException("cannot create an order created event in the database");
        }
    }

    private PreparedStatementCreator preparedStatementCreatorFor(Order order, Timestamp timestamp) {
        val aggregateId = order.getOrderId();
        val payload = orderJsonMapper.toJson(order);
        return connection -> preparedStatementFor(timestamp, ORDER_CREATED_EVENT_HANDLE, aggregateId, payload, connection);
    }

    private Map<String, Object> generatedKeys(KeyHolder keyHolder) {
        return Optional.ofNullable(keyHolder.getKeys())
                .orElse(Collections.emptyMap());
    }

    private long eventIdOrError(Map<String, Object> keys) {
        return (long) Optional.ofNullable(keys.get("event_id"))
                .orElseThrow(() -> new IllegalStateException("cannot get autogenerated event Id from database"));
    }

}